--- api/apps/meriter/src/domain/services/community.service.ts
+++ api/apps/meriter/src/domain/services/community.service.ts
@@ -1,7 +1,16 @@
-import { Injectable, Logger, NotFoundException, OnModuleInit } from '@nestjs/common';
+import {
+  Injectable,
+  Logger,
+  NotFoundException,
+  BadRequestException,
+  OnModuleInit,
+} from '@nestjs/common';
 import { InjectModel, InjectConnection } from '@nestjs/mongoose';
 import { Model, Connection } from 'mongoose';
-import { Community, CommunityDocument } from '../models/community/community.schema';
+import {
+  Community,
+  CommunityDocument,
+} from '../models/community/community.schema';
 import { User, UserDocument } from '../models/user/user.schema';
 import { CommunityId, UserId } from '../value-objects';
 import { EventBus } from '../events/event-bus';
@@ -12,6 +21,15 @@ export interface CreateCommunityDto {
   name: string;
   description?: string;
   avatarUrl?: string;
+  typeTag?:
+    | 'future-vision'
+    | 'marathon-of-good'
+    | 'team'
+    | 'political'
+    | 'housing'
+    | 'volunteer'
+    | 'corporate'
+    | 'custom';
   // Internal User IDs
   adminIds: string[];
   settings?: {
@@ -49,13 +67,12 @@ export class CommunityService {
   private readonly logger = new Logger(CommunityService.name);
 
   constructor(
-    @InjectModel(Community.name) private communityModel: Model<CommunityDocument>,
+    @InjectModel(Community.name)
+    private communityModel: Model<CommunityDocument>,
     @InjectModel(User.name) private userModel: Model<UserDocument>,
     @InjectConnection() private mongoose: Connection,
     private eventBus: EventBus,
-  ) { }
-
-
+  ) {}
 
   async getCommunity(communityId: string): Promise<Community | null> {
     // Query by internal ID only
@@ -63,12 +80,52 @@ export class CommunityService {
     return doc as any as Community;
   }
 
+  async getCommunityByTypeTag(typeTag: string): Promise<Community | null> {
+    const doc = await this.communityModel.findOne({ typeTag }).lean();
+    return doc as any as Community;
+  }
+
   async createCommunity(dto: CreateCommunityDto): Promise<Community> {
+    // Check for single-instance communities (Future Vision and Good Deeds Marathon)
+    if (dto.typeTag === 'future-vision' || dto.typeTag === 'marathon-of-good') {
+      const existing = await this.communityModel
+        .findOne({ typeTag: dto.typeTag })
+        .lean();
+      if (existing) {
+        throw new BadRequestException(
+          `Community with typeTag "${dto.typeTag}" already exists. Only one instance is allowed.`,
+        );
+      }
+    }
+
+    // Set default voting rules based on community type
+    const defaultVotingRules = {
+      allowedRoles: ['superadmin', 'lead', 'participant', 'viewer'] as (
+        | 'superadmin'
+        | 'lead'
+        | 'participant'
+        | 'viewer'
+      )[],
+      canVoteForOwnPosts: false, // Default: cannot vote for own posts
+      participantsCannotVoteForLead: false,
+      spendsMerits: true,
+      awardsMerits: true,
+    };
+
+    // For Good Deeds Marathon: Members cannot vote for Representative posts
+    if (dto.typeTag === 'marathon-of-good') {
+      defaultVotingRules.participantsCannotVoteForLead = true;
+    }
+
+    // For Future Vision: Members cannot vote for their own posts (already default)
+    // Additional rules can be set here if needed
+
     const community = {
       id: uid(),
       name: dto.name,
       description: dto.description,
       avatarUrl: dto.avatarUrl,
+      typeTag: dto.typeTag,
       adminIds: dto.adminIds,
       members: [],
       settings: {
@@ -210,27 +309,34 @@ export class CommunityService {
       { id: communityId },
       'members',
       userId,
-      'Community'
+      'Community',
     );
   }
 
   async isUserAdmin(communityId: string, userId: string): Promise<boolean> {
-    const community = await this.communityModel.findOne({
-      id: communityId,
-      adminIds: userId,
-    }).lean();
+    const community = await this.communityModel
+      .findOne({
+        id: communityId,
+        adminIds: userId,
+      })
+      .lean();
     return community !== null;
   }
 
   async isUserMember(communityId: string, userId: string): Promise<boolean> {
-    const community = await this.communityModel.findOne({
-      id: communityId,
-      members: userId
-    }).lean();
+    const community = await this.communityModel
+      .findOne({
+        id: communityId,
+        members: userId,
+      })
+      .lean();
     return community !== null;
   }
 
-  async getAllCommunities(limit: number = 50, skip: number = 0): Promise<Community[]> {
+  async getAllCommunities(
+    limit: number = 50,
+    skip: number = 0,
+  ): Promise<Community[]> {
     return this.communityModel
       .find({})
       .limit(limit)
@@ -294,22 +406,26 @@ export class CommunityService {
 
     // Update lastQuotaResetAt timestamp to current time
     const resetAt = new Date();
-    const updatedCommunity = await this.communityModel.findOneAndUpdate(
-      { id: communityId },
-      {
-        $set: {
-          lastQuotaResetAt: resetAt,
-          updatedAt: new Date()
-        }
-      },
-      { new: true }
-    ).lean();
+    const updatedCommunity = await this.communityModel
+      .findOneAndUpdate(
+        { id: communityId },
+        {
+          $set: {
+            lastQuotaResetAt: resetAt,
+            updatedAt: new Date(),
+          },
+        },
+        { new: true },
+      )
+      .lean();
 
     if (!updatedCommunity) {
       throw new NotFoundException('Community not found');
     }
 
-    this.logger.log(`Quota reset timestamp updated for community ${communityId} at ${resetAt.toISOString()}`);
+    this.logger.log(
+      `Quota reset timestamp updated for community ${communityId} at ${resetAt.toISOString()}`,
+    );
     return { resetAt };
   }
 }
