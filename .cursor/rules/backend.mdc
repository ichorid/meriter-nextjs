---
description: NestJS + tRPC backend patterns for Meriter API. Include when working in api package.
globs:
  - api/**/*
alwaysApply: false
---

# Backend Patterns (NestJS + tRPC + REST)

## Tech Stack
- NestJS 10 + TypeScript (strict)
- tRPC v11 for main API surface
- REST (`api-v1`) for auth/uploads/config compatibility endpoints
- MongoDB + Mongoose
- Zod shared contracts from `libs/shared-types`

## Backend Structure

```text
api/apps/meriter/src/
├── domain/
│   ├── models/                # Mongoose schemas/documents (community, publication, vote, ...)
│   ├── services/              # Business logic services (publication, vote, wallet, permission, ...)
│   ├── aggregates/            # Domain entities/aggregates
│   ├── events/                # Domain events and event bus
│   ├── value-objects/         # Strongly-typed domain identifiers and VOs
│   └── common/helpers/        # Domain helpers (e.g. priority community logic)
├── trpc/
│   ├── routers/               # tRPC routers (publications, votes, wallets, ...)
│   ├── middleware/            # tRPC middleware (permission checks, auth)
│   ├── context.ts             # Request context construction
│   └── trpc.ts                # Procedure helpers
├── api-v1/                    # REST modules (auth, uploads, config, common)
├── config/                    # Runtime configuration + validation schema
├── telegram/                  # Telegram integrations (content pipeline helpers)
├── tg-bots/                   # Telegram bot module/services
└── domain.module.ts           # Shared domain wiring module
```

## Module Wiring Rule
- Use a shared `domain.module.ts` for providers and model registration.
- Do not assume "one module per entity" layout.
- Keep business logic in `domain/services`, not in routers/controllers.

## API Layer Responsibilities

### tRPC (`trpc/routers`)
- Validate input with shared Zod schemas when possible.
- Perform transport-level checks and call domain services.
- Keep routers thin: orchestration + mapping only.

### REST (`api-v1`)
- Used for selected flows (auth/providers/uploads/config and compatibility routes).
- Reuse domain services and shared helpers instead of duplicating logic.
- Keep auth and permissions consistent with tRPC behavior.

## Permission Flow

1. Route/middleware resolves actor and target context.
2. `PermissionService` evaluates action-level permission.
3. Domain service enforces business constraints (wallet/quota/source rules).
4. Operation executes atomically (session/transaction where needed).
5. Events/notifications emitted after successful state change.

Never rely on UI assumptions for security-critical checks.

## Data and Schema Rules
- Shared API contracts: `libs/shared-types/src/`.
- Backend-only schemas/utilities: `api/apps/meriter/src/common/schemas/`.
- Mongoose documents remain in `domain/models/**`.
- When changing contract shape, update both backend usage and frontend consumers.

## Service Pattern

```typescript
@Injectable()
export class ExampleService {
  constructor(
    @InjectModel(ExampleSchemaClass.name)
    private readonly exampleModel: Model<ExampleDocument>,
  ) {}

  async execute(input: Input): Promise<Output> {
    // business logic, validation, persistence
  }
}
```

## Router Pattern

```typescript
export const exampleRouter = router({
  create: protectedProcedure
    .input(CreateExampleSchema)
    .mutation(async ({ ctx, input }) => {
      return ctx.exampleService.execute(input);
    }),
});
```

## Common Mistakes

❌ Putting business rules directly in tRPC routers/controllers  
❌ Duplicating validation instead of reusing shared schemas  
❌ Skipping permission checks for "internal" endpoints  
❌ Mixing REST/tRPC contracts without explicit mapping  
❌ Introducing backend-only DTOs into shared-types without cross-package need