---
description: React and Next.js patterns for frontend development. Include when working with web components, hooks, routes, and client data flows.
globs:
  - web/src/**/*
alwaysApply: false
---

# Frontend Patterns (React + Next.js)

## Tech Stack
- React 19 + Next.js 16 (App Router)
- TypeScript (strict)
- TanStack Query + tRPC client (`@trpc/react-query` v11)
- REST client via Axios (`lib/api/client.ts`, `lib/api/v1`)
- Tailwind CSS
- Zustand (with `devtools` + `persist` in stores)
- next-intl (i18n runtime and translations)

## Web Structure (web/src)
- `app/` — App Router pages/layouts/routes
- `components/` — UI building blocks
- `features/` — feature-focused modules
- `hooks/` — reusable hooks (`hooks/api/*` for API-facing hooks)
- `stores/` — Zustand stores
- `contexts/` — React Context providers (auth/app mode)
- `providers/` — app-level providers (Query/tRPC)
- `shared/` — shared UI/helpers/state used across features
- `lib/` — client libraries and utilities
- `config/` — frontend runtime/static configuration
- `types/` — frontend types
- `i18n/` — i18n config/request setup
- `generated/` — generated artifacts (currently build info)
- `__tests__/` — tests
- Route handlers are also used in App Router (`app/**/route.ts`) for auth link flows.

## Component Guidelines

### Component Structure
```typescript
// components/organisms/Publication/PublicationActions.tsx

'use client';

import { trpc } from '@/lib/trpc/client';
import { Button } from '@/components/ui/shadcn/button';

interface PublicationActionsProps {
  publicationId: string;
  communityId: string;
}

export function PublicationActions({ publicationId, communityId }: PublicationActionsProps) {
  const utils = trpc.useUtils();
  const voteMutation = trpc.votes.create.useMutation({
    onSuccess: async () => {
      await utils.publications.getById.invalidate({ id: publicationId });
      await utils.communities.getFeed.invalidate({ communityId });
    },
  });

  return (
    <div className="flex gap-2">
      <Button
        onClick={() =>
          voteMutation.mutate({
            targetType: 'publication',
            targetId: publicationId,
            quotaAmount: 1,
            walletAmount: 0,
            direction: 'up',
            communityId,
          })
        }
      >
        Vote
      </Button>
    </div>
  );
}
```

### Component Rules
- Prefer one primary component per file, but multiple related exports in a single file are allowed.
- Define explicit props types/interfaces.
- Use `'use client'` only when interactivity/browser APIs are required.
- Keep domain side effects in hooks; compose UI from smaller components.
- Prefer named exports for new components (existing default exports may remain where already used)

## Data Fetching

### tRPC (Authenticated)
```typescript
// hooks/api/usePublications.ts
import { trpc } from '@/lib/trpc/client';
import { STALE_TIME } from '@/lib/constants/query-config';

interface ListQueryParams {
  skip?: number;
  limit?: number;
  communityId?: string;
  userId?: string;
  tag?: string;
}

export function usePublications(params: ListQueryParams = {}) {
  return trpc.publications.getAll.useQuery(
    {
      communityId: params.communityId,
      authorId: params.userId,
      hashtag: params.tag,
      page: params.skip !== undefined ? Math.floor((params.skip || 0) / (params.limit || 20)) + 1 : undefined,
      pageSize: params.limit,
      limit: params.limit,
      skip: params.skip,
    },
    { staleTime: STALE_TIME.VERY_SHORT }
  );
}
```

### REST (Unauthenticated / specific endpoints)
```typescript
// lib/api/v1/index.ts
export const authApiV1 = {
  async clearCookies(): Promise<void> {
    await apiClient.post('/api/v1/auth/clear-cookies');
  },

  async authenticateFakeUser(): Promise<AuthResult> {
    // ...
  },

  async authenticateFakeSuperadmin(): Promise<AuthResult> {
    // ...
  },
};

export const configApiV1 = {
  async getConfig(): Promise<RuntimeConfig> {
    const response = await apiClient.get<{ success: true; data: RuntimeConfig }>(
      '/api/v1/config'
    );
    return response.data;
  },
};
```

## State Management

### Zustand Store Pattern
```typescript
// stores/ui.store.ts
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

interface UIState {
  activeModal: string | null;
  activeVotingTarget: string | null;
  votingTargetType: 'publication' | 'comment' | null;
  votingMode?: 'standard' | 'wallet-only' | 'quota-only';
}

interface UIActions {
  openModal: (modal: string) => void;
  closeModal: () => void;
  openVotingPopup: (
    targetId: string,
    targetType: 'publication' | 'comment' | null,
    mode?: 'standard' | 'wallet-only' | 'quota-only'
  ) => void;
  closeVotingPopup: () => void;
}

export const useUIStore = create<UIState & UIActions>()(
  devtools(
    persist(
      (set) => ({
        activeModal: null,
        activeVotingTarget: null,
        votingTargetType: null,
        votingMode: 'standard',
        openModal: (modal) => set({ activeModal: modal }),
        closeModal: () => set({ activeModal: null }),
        openVotingPopup: (targetId, targetType, mode = 'standard') =>
          set({ activeVotingTarget: targetId, votingTargetType: targetType, votingMode: mode }),
        closeVotingPopup: () =>
          set({ activeVotingTarget: null, votingTargetType: null }),
      }),
      { name: 'meriter-ui' }
    ),
    { name: 'UIStore' }
  )
);
```

### When to Use What
| State Type | Solution |
|------------|----------|
| Server data | TanStack Query (tRPC first) |
| Global UI state | Zustand |
| Cross-tree app state | React Context (`contexts/*`) |
| Form state | Local state or project form primitives |
| Component state | `useState` / `useReducer` |
| URL state | App Router params/search params |

## Styling (Tailwind)

### Class Organization
```tsx
<div 
  className={cn(
    // Layout
    "flex flex-col items-center",
    // Spacing
    "p-4 gap-2",
    // Visual
    "bg-white rounded-lg shadow",
    // Interactive
    "hover:bg-gray-50 transition-colors",
    // Conditional
    isActive && "ring-2 ring-blue-500"
  )}
/>
```

### Use `cn()` Utility
```typescript
// lib/utils.ts
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

## App Router Patterns

### Page Structure
```typescript
// app/meriter/communities/[id]/page.tsx

interface CommunityPageProps {
  params: Promise<{ id: string }>;
}

export default async function CommunityPage({ params }: CommunityPageProps) {
  const { id } = await params;
  return <CommunityPageClient communityId={id} />;
}
```

### Route-level Loading & Error Files
- Server `page.tsx` may use `params: Promise<{...}>` and pass resolved IDs to client components.
- `generateMetadata` may fetch backend data directly on server for dynamic titles.
- `loading.tsx` and `error.tsx` are optional App Router conventions.
- Use them when route-level loading/error boundaries are needed.
- Do not assume every route has these files.

## Custom Hooks Pattern
```typescript
// hooks/api/useVotes.ts
import { trpc } from '@/lib/trpc/client';
import { useVoteMutation } from './useVoteMutation';

export function useVoteOnPublication() {
  const utils = trpc.useUtils();

  return useVoteMutation({
    mutationFn: ({ publicationId, data, communityId }) =>
      utils.votes.create.mutateAsync({
        targetType: 'publication',
        targetId: publicationId,
        quotaAmount: data.quotaAmount ?? 0,
        walletAmount: data.walletAmount ?? 0,
        direction: data.direction ?? 'up',
        comment: data.comment ?? '',
        images: data.images,
        communityId: communityId!,
      }),
    onSuccessInvalidations: {
      publications: true,
      communities: true,
      comments: true,
      specificPublicationId: (variables) => variables?.publicationId,
    },
  });
}
```

## API Layer Conventions
- Use `trpc` client from `@/lib/trpc/client` for authenticated domain operations.
- Use REST wrappers from `@/lib/api/v1` for auth/bootstrap-specific REST endpoints (`fake auth`, `clear cookies`, runtime config, etc.).
- Central REST transport lives in `@/lib/api/client`.
- App-level query+tRPC providers are configured in `@/providers/QueryProvider`.

## Common Mistakes

❌ Assuming strict "one component per file" (project allows multiple related exports per file)
❌ Importing paths/modules that are not present in the project structure
❌ Mixing old singular router naming with current tRPC routers (`publications`, `votes`, etc.)
❌ Putting domain side effects directly into large UI components instead of hooks
❌ Mutating state directly in Zustand
❌ Treating ad-hoc `fetch` as default for domain API calls (prefer project API clients; server metadata/auth edge cases can still use `fetch`)

## Implemented Frontend Features (Current Codebase)

- Investment UI flows: invest dialog/button, investment breakdown, read-only post investment settings.
- Post closing flow: close dialog, closing summary blocks, related action controls.
- Tappalka UI and hooks: onboarding, pair/choice/progress hooks, tappalka screen/cards.
- Auth extras: fake auth hooks and passkey-related UI/hooks (`usePasskeys`, `PasskeySection`).
- i18n runtime usage with `next-intl` (`useTranslations` across app/components/features).
