---
description: React and Next.js patterns for frontend development. Include when working with web components, hooks, routes, and client data flows.
globs:
  - web/src/**/*
alwaysApply: false
---

# Frontend Patterns (React + Next.js)

Full monorepo and layer overview: @architecture.mdc.

## Tech Stack
- React 19 + Next.js 16 (App Router)
- TypeScript (strict)
- TanStack Query + tRPC client (`@trpc/react-query` v11)
- REST client via Axios (`lib/api/client.ts`, `lib/api/v1`)
- Tailwind CSS
- Zustand (store middleware is mixed by store: some use `devtools + persist`, some only `devtools`, some plain `create`)
- next-intl (i18n runtime and translations)

## Web Structure (web/src)
- `app/` — App Router pages/layouts/routes
- `components/` — UI building blocks
- `features/` — feature-focused modules
- `hooks/` — reusable hooks (`hooks/api/*` for API-facing hooks)
- `stores/` — Zustand stores
- `contexts/` — React Context providers (auth/app mode)
- `providers/` — app-level providers (Query/tRPC)
- `shared/` — shared UI/helpers/state used across features
- `lib/` — client libraries and utilities
- `config/` — frontend runtime/static configuration
- `types/` — frontend types
- `i18n/` — i18n config/request setup
- `generated/` — generated artifacts (currently build info)
- `__tests__/` — tests
- Route handlers are also used in App Router (`app/**/route.ts`) for auth link flows.

## Component Guidelines

### Component Structure
```typescript
// components/organisms/Publication/PublicationActions.tsx

'use client';

import { useVoteOnPublicationWithComment } from '@/hooks/api/useVotes';
import { Button } from '@/components/ui/shadcn/button';

interface PublicationActionsProps {
  publicationId: string;
}

export function PublicationActions({ publicationId }: PublicationActionsProps) {
  const voteMutation = useVoteOnPublicationWithComment();

  return (
    <div className="flex gap-2">
      <Button
        onClick={() =>
          voteMutation.mutateAsync({
            publicationId,
            data: {
              walletAmount: 1,
              direction: 'up',
              comment: '',
            },
          })
        }
      >
        Vote
      </Button>
    </div>
  );
}
```

### Component Rules
- Prefer one primary component per file, but multiple related exports in a single file are allowed.
- Define explicit props types/interfaces.
- Use `'use client'` only when interactivity/browser APIs are required.
- Keep domain side effects in hooks; compose UI from smaller components.
- Prefer named exports for new components (existing default exports may remain where already used)

## Data Fetching

### tRPC (Authenticated)
```typescript
// hooks/api/usePublications.ts
import { trpc } from '@/lib/trpc/client';
import { STALE_TIME } from '@/lib/constants/query-config';

interface ListQueryParams {
  skip?: number;
  limit?: number;
  communityId?: string;
  userId?: string;
  tag?: string;
}

export function usePublications(params: ListQueryParams = {}) {
  return trpc.publications.getAll.useQuery(
    {
      communityId: params.communityId,
      authorId: params.userId,
      hashtag: params.tag,
      page: params.skip !== undefined ? Math.floor((params.skip || 0) / (params.limit || 20)) + 1 : undefined,
      pageSize: params.limit,
      limit: params.limit,
      skip: params.skip,
    },
    { staleTime: STALE_TIME.VERY_SHORT }
  );
}
```

### REST (Specialized endpoint families)
- Use REST wrappers for endpoint families that remain REST by design (auth/bootstrap, OAuth callbacks, uploads, runtime config).
- Use tRPC for authenticated domain operations.
- REST requests may still be cookie-authenticated depending on endpoint behavior.

```typescript
// lib/api/v1/index.ts
export const authApiV1 = {
  async clearCookies(): Promise<void> {
    await apiClient.post('/api/v1/auth/clear-cookies');
  },

  async authenticateFakeUser(): Promise<AuthResult> {
    // ...
  },

  async authenticateFakeSuperadmin(): Promise<AuthResult> {
    // ...
  },
};

export const configApiV1 = {
  async getConfig(): Promise<RuntimeConfig> {
    const response = await apiClient.get<{ success: true; data: RuntimeConfig }>(
      '/api/v1/config'
    );
    return response.data;
  },
};
```

## State Management

### Zustand Store Pattern
```typescript
// stores/ui.store.ts
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

interface UIState {
  activeModal: string | null;
  activeVotingTarget: string | null;
  votingTargetType: 'publication' | 'comment' | null;
  votingMode?: 'standard' | 'wallet-only' | 'quota-only';
}

interface UIActions {
  openModal: (modal: string) => void;
  closeModal: () => void;
  openVotingPopup: (
    targetId: string,
    targetType: 'publication' | 'comment' | null,
    mode?: 'standard' | 'wallet-only' | 'quota-only'
  ) => void;
  closeVotingPopup: () => void;
}

export const useUIStore = create<UIState & UIActions>()(
  devtools(
    persist(
      (set) => ({
        activeModal: null,
        activeVotingTarget: null,
        votingTargetType: null,
        votingMode: 'standard',
        openModal: (modal) => set({ activeModal: modal }),
        closeModal: () => set({ activeModal: null }),
        openVotingPopup: (targetId, targetType, mode = 'standard') =>
          set({ activeVotingTarget: targetId, votingTargetType: targetType, votingMode: mode }),
        closeVotingPopup: () =>
          set({ activeVotingTarget: null, votingTargetType: null }),
      }),
      { name: 'meriter-ui' }
    ),
    { name: 'UIStore' }
  )
);
```

### When to Use What
| State Type | Solution |
|------------|----------|
| Server data | TanStack Query (tRPC first) |
| Global UI state | Zustand |
| Cross-tree app state | React Context (`contexts/*`) |
| Form state | Local state or project form primitives |
| Component state | `useState` / `useReducer` |
| URL state | App Router params/search params |

## Styling (Tailwind)

### Class Organization
```tsx
<div 
  className={cn(
    // Layout
    "flex flex-col items-center",
    // Spacing
    "p-4 gap-2",
    // Visual
    "bg-white rounded-lg shadow",
    // Interactive
    "hover:bg-gray-50 transition-colors",
    // Conditional
    isActive && "ring-2 ring-blue-500"
  )}
/>
```

### Use `cn()` Utility
```typescript
// lib/utils.ts
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

## App Router Patterns

### Page Structure
```typescript
// app/meriter/communities/[id]/page.tsx

interface CommunityPageProps {
  params: Promise<{ id: string }>;
}

export default async function CommunityPage({ params }: CommunityPageProps) {
  const { id } = await params;
  return <CommunityPageClient communityId={id} />;
}
```

### Route-level Loading & Error Files
- Server `page.tsx` may use `params: Promise<{...}>` and pass resolved IDs to client components.
- `generateMetadata` may fetch backend data directly on server for dynamic titles.
- `loading.tsx` and `error.tsx` are optional App Router conventions.
- Use them when route-level loading/error boundaries are needed.
- Do not assume every route has these files.

## Custom Hooks Pattern
```typescript
// hooks/api/useVotes.ts
import { useQueryClient } from '@tanstack/react-query';
import { trpc } from '@/lib/trpc/client';

export function useVoteOnPublicationWithComment() {
  const queryClient = useQueryClient();
  const mutation = trpc.votes.createWithComment.useMutation({
    // includes optimistic updates + cache invalidation logic in current implementation
  });

  return {
    ...mutation,
    mutateAsync: ({
      publicationId,
      data,
      communityId,
    }: {
      publicationId: string;
      data: {
        quotaAmount?: number;
        walletAmount?: number;
        comment?: string;
        direction?: 'up' | 'down';
        images?: string[];
      };
      communityId?: string;
    }) =>
      mutation.mutateAsync({
        targetType: 'publication',
        targetId: publicationId,
        quotaAmount: data.quotaAmount ?? 0,
        walletAmount: data.walletAmount ?? 0,
        direction: data.direction ?? 'up',
        comment: data.comment ?? '',
        images: data.images,
        communityId: communityId || '',
      }),
  };
}
```

## API Layer Conventions
- Use `trpc` client from `@/lib/trpc/client` for authenticated domain operations.
- Use REST wrappers from `@/lib/api/v1` for auth/bootstrap-specific REST endpoints (`fake auth`, `clear cookies`, runtime config, etc.).
- Central REST transport lives in `@/lib/api/client`.
- App-level query+tRPC providers are configured in `@/providers/QueryProvider`.

### Vote API Input Contracts
- `votes.create` uses `CreateVoteDtoSchema`: `targetType`, `targetId`, `quotaAmount?`, `walletAmount?`, `attachedCommentId?`.
- For voting on comments in domain flows, the target is a vote entity (`targetType: 'vote'`).
- `votes.createWithComment` uses `VoteWithCommentDtoSchema` and accepts weighted vote or neutral comment (`comment`), with optional `direction` and `images`.
- `VoteWithCommentDtoSchema` currently allows `targetType: 'publication' | 'comment' | 'vote'`, but `votes.createWithComment` enforces runtime validation and rejects `'comment'` (requires `'publication'` or `'vote'`).
- `communityId` is resolved server-side from target and is not part of `votes.create` or `votes.createWithComment` input schemas.

## Common Mistakes

❌ Assuming strict "one component per file" (project allows multiple related exports per file)
❌ Importing paths/modules that are not present in the project structure
❌ Mixing old singular router naming with current tRPC routers (`publications`, `votes`, etc.)
❌ Putting domain side effects directly into large UI components instead of hooks
❌ Mutating state directly in Zustand
❌ Treating ad-hoc `fetch` as default for domain API calls (prefer project API clients; server metadata/auth edge cases can still use `fetch`)

## Implemented Frontend Features (Current Codebase)

- Investment UI flows: invest dialog/button, investment breakdown, read-only post investment settings.
- Post closing flow: close dialog, closing summary blocks, related action controls.
- Tappalka UI and hooks: onboarding, pair/choice/progress hooks, tappalka screen/cards.
- Auth extras: fake auth hooks and passkey-related UI/hooks (`usePasskeys`, `PasskeySection`).
- i18n runtime usage with `next-intl` (`useTranslations` across app/components/features).
- Post forwarding flows: propose forward, forward, reject forward, and related UI controls/popups.
- Deleted post lifecycle UI/API hooks: deleted lists, restore, and permanent delete flows.
- Team management flows: join team, invite to team, assign lead, and team request handling.
- Telegram/WebApp integration: telegram store/init handling, haptics helpers, and Telegram-specific UI behavior.
- Dev/test auth flows and fake-vote tooling in test-auth mode (including fake superadmin-related actions).
- Notifications flows: notifications page/client and API hooks (`useNotifications`).
- Favorites flows: favorites API hooks and profile favorites route.
- Search flows: dedicated search page/client and API hooks (`useSearch`).
- Admin/settings panels for categories and superadmin management.
- Taxonomy-enabled publication flows: taxonomy fields in create/read UI (`impactArea`, `beneficiaries`, `methods`, `stage`, `helpNeeded`) with translation helpers.
